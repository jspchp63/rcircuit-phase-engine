# RCIRCUIT v2.0 — Resonant Compute Pipeline

> Goal: Turn the phase-based ideas from v1.x into a **single end-to-end compute pipeline**  
> that can be implemented as code and compared against FLOPS-based GPUs.

This document defines the **v2.0 Resonant Compute Pipeline** for RCIRCUIT.  
It connects local phase updates, resonance scoring, and global propagation  
into one coherent execution loop.

---

## 1. Design Goals

v2.0 focuses on **pipeline structure**, not full optimization.

- Provide a **single pass** from input Δsignal → output resonance metrics.
- Make each stage **observable & testable** (can be logged in experiments).
- Stay **implementation-agnostic**:
  - No hardware details.
  - No vendor assumptions (NVIDIA, TPU, etc.).
- Be **simple enough** to implement in `src/` as v2.0 prototype.

Non-goals for v2.0:

- No full scheduler yet.
- No multi-device distribution.
- No automatic differentiation / training loop.

---

## 2. Core Concepts (Recap from v1.x)

We assume the following primitives from v1.0–v1.9:

- **PhaseNode**
  - Holds local `phase` state.
- **Δsignal (delta_signal)**
  - Represents meaningful change, not absolute value.
- **Resonance Score**
  - A scalar that encodes “how aligned” a node or region is with its neighbors.
- **Coherence Map**
  - Local neighborhood structure: which nodes influence which.

v2.0 adds one key idea:

- **Resonant Compute Pulse**
  - A single “tick” where input deltas are applied,  
    local phases updated, resonance measured, and (optionally)  
    phase is propagated to neighbors.

---

## 3. Resonant Compute Pipeline (High-Level)

A single **RCIRCUIT v2.0 step** consists of:

1. **Input Stage — Δsignal Injection**
   - Receive external inputs:
     - sensor deltas
     - logical deltas (e.g. token change, state change)
   - Map them to nodes: `input_map[node_id] = delta_signal`.

2. **Local Phase Update**
   - For each node:
     - Update `phase` using its Δsignal and modulation rule.
     - Example:
       ```text
       phase_new = phase_old + gain * delta_signal
       ```
     - This may include basic non-linearity (e.g. clamp, wrap, tanh).

3. **Local Resonance Scoring**
   - For each node:
     - Compare node phase to its neighbors.
     - Compute `local_resonance_score[node_id]`.
     - Example:
       ```text
       score = 1 - normalized_phase_difference_to_neighbors
       ```

4. **Regional / Field Aggregation**
   - Aggregate local scores into:
     - **region_resonance** (per cluster / module)
     - **global_resonance** (single scalar)
   - This defines the **system-level coherence** for this pulse.

5. **Global Propagation / Feedback (Optional in v2.0)**
   - Using the resonance scores, optionally:
     - Modulate future gains.
     - Gate propagation to other regions.
   - This stage is where **“movement-minimizing propagation”** logic lives.

6. **Output Stage**
   - Return:
     - updated phases
     - resonance scores
     - global metrics (e.g. `R_global`, `collapse_risk`, `stability_index`)

---

## 4. Minimal Data Structures (Conceptual)

These are not final code signatures, just conceptual shapes.

```text
PhaseNode:
    id: int
    phase: float
    neighbors: List[node_id]

DeltaSignal:
    node_id: int
    value: float

ResonanceMetrics:
    local: Dict[node_id, float]
    region: Dict[region_id, float]
    global: float
For v2.0 we only need:

A consistent way to identify nodes.

A way to attach Δsignal to each node at each pulse.

A way to compute and log resonance metrics.

5. v2.0 Pseudocode (Single Pulse)
This pseudocode is the reference loop for implementation.


def rcircuit_pulse_v2_0(phase_state, delta_signals, graph, params):
    """
    phase_state: Dict[node_id, float]
    delta_signals: Dict[node_id, float]
    graph: neighborhood structure (adjacency list or similar)
    params: { 'gain': float, ... }

    returns:
        updated_phase_state, resonance_metrics
    """

    # 1) Local Phase Update
    new_phase_state = {}
    for node_id, old_phase in phase_state.items():
        delta = delta_signals.get(node_id, 0.0)
        gain = params.get("gain", 0.1)

        # simple linear update (can evolve later)
        new_phase = old_phase + gain * delta

        # optional: clamp or wrap
        # new_phase = wrap_to_pi(new_phase)  # example

        new_phase_state[node_id] = new_phase

    # 2) Local Resonance Scoring
    local_scores = {}
    for node_id, phase in new_phase_state.items():
        neighbors = graph.get(node_id, [])
        if not neighbors:
            local_scores[node_id] = 0.0
            continue

        # compute average neighbor phase
        neighbor_phases = [new_phase_state[n] for n in neighbors if n in new_phase_state]
        if not neighbor_phases:
            local_scores[node_id] = 0.0
            continue

        avg_neighbor_phase = sum(neighbor_phases) / len(neighbor_phases)

        # simple inverse difference as resonance proxy
        phase_diff = abs(phase - avg_neighbor_phase)
        # normalize & invert: higher score = more coherent
        score = max(0.0, 1.0 - phase_diff)
        local_scores[node_id] = score

    # 3) Global Aggregation
    if local_scores:
        global_resonance = sum(local_scores.values()) / len(local_scores)
    else:
        global_resonance = 0.0

    resonance_metrics = {
        "local": local_scores,
        "global": global_resonance,
    }

    return new_phase_state, resonance_metrics
This is not the final engine, but:

It demonstrates:

Δsignal-driven phase update.

Local coherence measurement.

Global resonance metric.

It can be used directly in experiments/
to show “movement-light, resonance-aware compute”.

6. Suggested Experiments for v2.0
To make v2.0 meaningful to external researchers:

Noise vs. Coherence Experiment

Inject random Δsignal noise into a subset of nodes.

Measure how quickly global_resonance falls.

Compare to a baseline (no structure).

Structured Input vs. Random Input

Feed coherent pattern (e.g. sin wave across nodes).

Compare resonance trajectory with random input.

Graph Topology Impact

Same Δsignal, different graphs:

line

grid

small-world

fully connected

Show that the graph structure changes resonance dynamics.

All of these can be logged using the same v2.0 pulse API.

7. Roadmap: v2.x → v3.0
After v2.0:

v2.1–v2.5

refine scoring functions (e.g. proper normalization, phase wrapping)

add multiple resonance channels (amplitude, frequency, phase offset)

v2.6–v2.9

introduce basic gating & routing (movement-minimizing propagation)

v3.0

define RCIRCUIT vs GPU comparison protocol:

energy per useful update

data movement vs coherence gain

collapse boundary under load

8. Summary
v2.0 moves RCIRCUIT from:

“collection of phase-based ideas (v1.x)”

to:

“a single, testable Resonant Compute Pipeline
that external researchers can implement, benchmark, and criticize.”

The goal is not perfection.

The goal is to give the world a clear, minimal, and honest
definition of what “phase-based compute” looks like in code.
