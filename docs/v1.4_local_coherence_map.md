# RCIRCUIT v1.4 — Local Coherence Map (Skeleton)

## Purpose
Define how a group of phase nodes establishes **local stability**  
before any global propagation happens.

This is the core mechanism that differentiates RCIRCUIT from GPU FLOPS.

---

## 1. Input
A set of N nodes, each with:
- `phase`
- `delta_signal`
- `coupling_weight`

Assume **adjacent node coupling only** (v1.3 rule).

---

## 2. Coherence Score (minimal version)

For a local cluster of K nodes:

coherence = 1 - (variance(phases))


Interpretation:
- variance ↓ → coherence ↑  
- coherence ∈ [0, 1]

This is the simplest public-safe formulation.

---

## 3. Stability Condition

A cluster is **locally stable** when:

coherence >= stability_threshold


Default public threshold:

stability_threshold = 0.85


Below threshold = “UNSTABLE”.

---

## 4. Local Coherence Map

A 1D strip of nodes:

[N1]—[N2]—[N3]—[N4]—...—[Nk]


Map rule:

for each cluster window W of size K:
compute coherence(W)
mark W as STABLE or UNSTABLE

Example window size:
K = 3

Output (minimal):

W1: 0.92 → STABLE
W2: 0.41 → UNSTABLE
W3: 0.88 → STABLE

---

## 5. Why This Matters
GPUs perform **global synchronous updates** (massive data motion).  
RCIRCUIT performs **local coherence first**, then global propagation only if stable.

This reduces:
- heat
- power
- interconnect load  
- synchronization jitter

---

## 6. Public-Safe Notes
Full coherence model includes:
- harmonic lock detection  
- phase drift compensation  
- local-chaos suppression  

These appear in v2.x and remain private for safety/IP reasons.

---

## 7. Next Step
v1.5 — Resonance Field Accumulator (Skeleton)
